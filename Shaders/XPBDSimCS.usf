#include "/Engine/Private/Common.ush"



#if SIMPLE_COLLISION_FEEDBACK

#ifndef THREAD_COUNT
#define THREAD_COUNT 32
#endif // !THREAD_COUNT


Buffer<float4> InputPositionBuffer;
Buffer<uint> MaskBuffer;
RWBuffer<float4> OutputPositionBuffer;
RWBuffer<half4> VelocityBuffer;


RWBuffer<half4> FeedbackBuffer;
RWBuffer<uint> FeedbackBufferSizes;

groupshared uint GroupWriteOffsets[2 * THREAD_COUNT];

groupshared uint GroupWriteStart;

//x: 弹簧原长；y: DeltaTime的逆
float4 SpringParams;

//xyz: 球体坐标 z: 半径
float4 SphereCollisionParams;

//-0.5*(||x_i - x_j|| - L) * normalize(x_i - x_j)
void AccumulateSpringProj(inout float3 Acc, float3 PositionA, float3 PositionB, float StaticLength) {
    float3 BToA = PositionA - PositionB;
    float Distance = dot(BToA, BToA);
    Distance = sqrt(Distance);
    float3 Dir = BToA / Distance;
    Acc += -0.5 * (Distance - StaticLength) * Dir;
}



[numthreads(THREAD_COUNT, 1, 1)]
void MainCS(uint3 GroupThreadId : SV_GroupThreadID, uint3 ThreadId : SV_DispatchThreadID) {
    float3 Position = InputPositionBuffer[ThreadId.x].rgb;
    uint Mask = MaskBuffer[ThreadId.x];



    float StaticLength = SpringParams.x;

    uint Row = ThreadId.x / 32;
    uint Col = ThreadId.x % 32;

    uint OtherId;
    float3 OtherPosition;
    float3 Acc = 0.0;
    float ProjN = 0.0;

    //up
    if (Row != 0) {
        OtherId = (Row - 1) * 32 + Col;
        OtherPosition = InputPositionBuffer[OtherId].xyz;
        AccumulateSpringProj(Acc, Position, OtherPosition, StaticLength);
        ProjN += 1.0;
    }

    //down
    if (Row != 31) {
        OtherId = (Row + 1) * 32 + Col;
        OtherPosition = InputPositionBuffer[OtherId].xyz;
        AccumulateSpringProj(Acc, Position, OtherPosition, StaticLength);
        ProjN += 1.0;
    }

    //left
    if (Col != 0) {
        OtherId = ThreadId.x - 1;
        OtherPosition = InputPositionBuffer[OtherId].xyz;
        AccumulateSpringProj(Acc, Position, OtherPosition, StaticLength);
        ProjN += 1.0;
    }

    //right
    if (Col != 31) {
        OtherId = ThreadId.x + 1;
        OtherPosition = InputPositionBuffer[OtherId].xyz;
        AccumulateSpringProj(Acc, Position, OtherPosition, StaticLength);
        ProjN += 1.0;
    }

    // ------------------------ 碰撞 ----------------------
    float SphereRadius = SphereCollisionParams.w;
    float3 SphereCenter = SphereCollisionParams.xyz;
    float3 CenterToPosition = Position - SphereCenter;
    float DistSqr = dot(CenterToPosition, CenterToPosition);
    uint bIsCollis = 0;

    float3 Normal = 0;
    //球体内
    if (DistSqr < SphereRadius * SphereRadius) {
        Normal = CenterToPosition * rsqrt(DistSqr);
        float3 Offset = SphereCenter + Normal * SphereRadius - Position;
        Acc = Offset;
        ProjN = 1.0;
        bIsCollis = 1;
    }

    if (Mask == 1) bIsCollis = 0;

    // ------------------------ 归约 ----------------------
    uint Thread = GroupThreadId.x;
    GroupWriteOffsets[Thread] = bIsCollis;
    GroupMemoryBarrierWithGroupSync();

    int OutBuffer = 0, InBuffer = 1;

    [unroll]
    for (uint Offset = 1; Offset < THREAD_COUNT; Offset = Offset << 1) {

        OutBuffer = 1 - OutBuffer;
        InBuffer = 1 - InBuffer;
        if (Thread >= Offset) {
            GroupWriteOffsets[OutBuffer * THREAD_COUNT + Thread] = GroupWriteOffsets[InBuffer * THREAD_COUNT + Thread - Offset] + GroupWriteOffsets[InBuffer * THREAD_COUNT + Thread];
        }
        else {
            GroupWriteOffsets[OutBuffer * THREAD_COUNT + Thread] = GroupWriteOffsets[InBuffer * THREAD_COUNT + Thread];
        }

        GroupMemoryBarrierWithGroupSync();
    }

    if (Thread == 0) {
        uint NumGroupFreeIDs = GroupWriteOffsets[(OutBuffer + 1) * THREAD_COUNT - 1];
        InterlockedAdd(FeedbackBufferSizes[0], NumGroupFreeIDs, GroupWriteStart);
    }

    GroupMemoryBarrierWithGroupSync();

    if (bIsCollis) {
        uint WriteOffset = GroupWriteStart + GroupWriteOffsets[OutBuffer * THREAD_COUNT + Thread] - bIsCollis;
        FeedbackBuffer[WriteOffset] = half4(-Normal, 1.0);
    }

    if (Mask == 1) return;
    // ------------------------ 结算 ----------------------
    float3 Transform = Acc / ProjN;

    float3 NewPosition = Position + Transform;
    float3 Velocity = Transform * SpringParams.y;
    OutputPositionBuffer[ThreadId.x] = float4(NewPosition, 1.0);
    VelocityBuffer[ThreadId.x] += float4(Velocity, 1.0);
}
#endif